(* Communication channels between PKG, BS and UE*)
free pkg_to_bs: channel [private].
free bs_to_ue: channel.

(*==============================================*)
(*==============================================*)

(*Data Types*)
type public_key.
type secret_key.
type ID.

(*==============================================*)
(*==============================================*)

(*Functions*)

(* Get public key for a particular secret key *)
fun get_public_key(secret_key): public_key.

(* Generate secret key based on ID, parent secret key *)
(* This function is abstracted for simplicity*)
fun generate_secret_key(secret_key, ID): secret_key.

(* Get public key for base station *)
fun generate_public_key(secret_key): public_key.

(* Sign a message using E2IBS scheme *)
fun E2IBS_sign(bitstring, secret_key): bitstring.


(*==============================================*)
(*==============================================*)

(* Destructors *)

(* Verify the signature of a message*)
reduc forall m: bitstring, k: secret_key;
    checksign(E2IBS_sign(m, k), get_public_key(k)) = m.

(* Verify the public key using parent public key*)
reduc forall k: secret_key, xID: ID;
    parentkey(generate_public_key(generate_secret_key(k, xID))) = k.

(*==============================================*)
(*==============================================*)

(* Secrecy queries *)

(*Attacker should not have access to the private keys*)
free secret_key_pkg, secret_key_bs: secret_key [private].

query attacker (secret_key_pkg);
    attacker (secret_key_bs).

(*==============================================*)
(*==============================================*)

(* Authentication queries *)
event authentication_successful(public_key).
event begin_signing(public_key).


query x: public_key; inj-event(authentication_successful(x))
    ==> inj-event(begin_signing(x)).


(*==============================================*)
(*Core_PKG process*)
let Core_PKG(secret_key_pkg: secret_key) =
    (*Generate Keys for BS*)
    in(pkg_to_bs, ID_BS: ID);
    let secret_key_bs = generate_secret_key(secret_key_pkg, ID_BS) in
        out(pkg_to_bs, (generate_public_key(secret_key_bs), secret_key_bs)).


(*==============================================*)

(*Base-station process*)
let BS() =
    (*Get new keys generated by PKG*)
    new ID_BS: ID;
    out(pkg_to_bs, ID_BS);
    in(pkg_to_bs, (public_key_bs: public_key, secret_key_bs: secret_key));

    (*Sign the SIB1 message*)
    new SIB1: bitstring;
    event begin_signing(public_key_bs);
    let sig_SIB1 = E2IBS_sign(SIB1, secret_key_bs) in
        out(bs_to_ue, (SIB1, sig_SIB1, ID_BS, public_key_bs)).

(*==============================================*)

(*UE process*)
let UE(public_key_pkg: public_key) =
    (*Receive and verify signature*)
    in(bs_to_ue, (SIB1: bitstring, sig_SIB1:bitstring, ID_BS: ID, public_key_bs: public_key));

    (* Check whether signature is valid*)
    let (= SIB1) = checksign(sig_SIB1, public_key_bs) in
    (* Verify BS’s public-key*)
    let(= public_key_pkg) = get_public_key(parentkey(public_key_bs)) in
    event authentication_successful(public_key_bs).

(*==============================================*)
(*==============================================*)
(* Main process*)
process
    (* Generate PKG’s secret key*)
    new secret_key_pkg: secret_key;

    (* Start all individual processes in parallel*)
    (Core_PKG(secret_key_pkg) | !BS() |!UE(get_public_key(secret_key_pkg)))